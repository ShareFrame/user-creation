// Code generated by MockGen. DO NOT EDIT.
// Source: db.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	models "github.com/ShareFrame/user-management/internal/models"
	dynamodb "github.com/aws/aws-sdk-go-v2/service/dynamodb"
	gomock "github.com/golang/mock/gomock"
)

// MockDynamoDBService is a mock of DynamoDBService interface.
type MockDynamoDBService struct {
	ctrl     *gomock.Controller
	recorder *MockDynamoDBServiceMockRecorder
}

// MockDynamoDBServiceMockRecorder is the mock recorder for MockDynamoDBService.
type MockDynamoDBServiceMockRecorder struct {
	mock *MockDynamoDBService
}

// NewMockDynamoDBService creates a new mock instance.
func NewMockDynamoDBService(ctrl *gomock.Controller) *MockDynamoDBService {
	mock := &MockDynamoDBService{ctrl: ctrl}
	mock.recorder = &MockDynamoDBServiceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDynamoDBService) EXPECT() *MockDynamoDBServiceMockRecorder {
	return m.recorder
}

// CheckEmailExists mocks base method.
func (m *MockDynamoDBService) CheckEmailExists(ctx context.Context, email string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckEmailExists", ctx, email)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckEmailExists indicates an expected call of CheckEmailExists.
func (mr *MockDynamoDBServiceMockRecorder) CheckEmailExists(ctx, email interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckEmailExists", reflect.TypeOf((*MockDynamoDBService)(nil).CheckEmailExists), ctx, email)
}

// StoreUser mocks base method.
func (m *MockDynamoDBService) StoreUser(ctx context.Context, user models.CreateUserResponse, event models.UserRequest) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreUser", ctx, user, event)
	ret0, _ := ret[0].(error)
	return ret0
}

// StoreUser indicates an expected call of StoreUser.
func (mr *MockDynamoDBServiceMockRecorder) StoreUser(ctx, user, event interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreUser", reflect.TypeOf((*MockDynamoDBService)(nil).StoreUser), ctx, user, event)
}

// MockDynamoDBAPI is a mock of DynamoDBAPI interface.
type MockDynamoDBAPI struct {
	ctrl     *gomock.Controller
	recorder *MockDynamoDBAPIMockRecorder
}

// MockDynamoDBAPIMockRecorder is the mock recorder for MockDynamoDBAPI.
type MockDynamoDBAPIMockRecorder struct {
	mock *MockDynamoDBAPI
}

// NewMockDynamoDBAPI creates a new mock instance.
func NewMockDynamoDBAPI(ctrl *gomock.Controller) *MockDynamoDBAPI {
	mock := &MockDynamoDBAPI{ctrl: ctrl}
	mock.recorder = &MockDynamoDBAPIMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDynamoDBAPI) EXPECT() *MockDynamoDBAPIMockRecorder {
	return m.recorder
}

// PutItem mocks base method.
func (m *MockDynamoDBAPI) PutItem(ctx context.Context, input *dynamodb.PutItemInput, opts ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, input}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PutItem", varargs...)
	ret0, _ := ret[0].(*dynamodb.PutItemOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PutItem indicates an expected call of PutItem.
func (mr *MockDynamoDBAPIMockRecorder) PutItem(ctx, input interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, input}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PutItem", reflect.TypeOf((*MockDynamoDBAPI)(nil).PutItem), varargs...)
}

// Query mocks base method.
func (m *MockDynamoDBAPI) Query(ctx context.Context, input *dynamodb.QueryInput, opts ...func(*dynamodb.Options)) (*dynamodb.QueryOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, input}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(*dynamodb.QueryOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockDynamoDBAPIMockRecorder) Query(ctx, input interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, input}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockDynamoDBAPI)(nil).Query), varargs...)
}
